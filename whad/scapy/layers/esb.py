from scapy.packet import Packet, bind_layers
from scapy.fields import StrField, StrFixedLenField, XByteField, \
    FieldLenField, BitField, BitEnumField, XShortField, StrLenField
from scapy.config import conf
from struct import pack, unpack

from whad.helpers import bits_to_bytes, bytes_to_bits, bitwise_xor

USER_DLT = 148

def calculate_crc_byte(crc,byte,bits):
    '''
    This function calculates the temporary value generated by an iteration of CRC calculation.

    :param crc: previous temporary value of CRC
    :param byte: byte to use in the current iteration
    :param bits: number of bits of the byte to take into account in the calculation
    '''
    polynome = bytes_to_bits(b'\x10\x21')
    crc_ba = bytes_to_bits(crc)
    byte_ba = bytes_to_bits(bytes([byte]))
    crc_ba = bitwise_xor(crc_ba,byte_ba + "00000000")
    while bits>0:
        bits-=1
        if crc_ba[0:1] == '1':
            crc_ba = crc_ba[1:]+'0'
            crc_ba = bitwise_xor(crc_ba,polynome)
        else:
            crc_ba = crc_ba[1:]+'0'
    return bits_to_bytes(crc_ba)

def calculate_crc(packet):
    '''
    This function calculates the CRC of an Enhanced Shockburst packet.

    :param packet: raw bytes of packet (without CRC and preamble)
    :return: calculated CRC

    :Example:
        >>> calculate_crc(bytes.fromhex('e846f92fa429006100007f57ff80004900')).hex()
        '9ed4'
    '''
    crc = b"\xFF\xFF"
    for x in packet[:-1]:
        crc = calculate_crc_byte(crc,x,8)
    crc = calculate_crc_byte(crc, packet[-1],1)
    return crc

# Field representing a ShockBurst address
class SBAddressField(StrLenField):
    def __init__(self, name, default, length_from):
        StrLenField.__init__(self, name, default,length_from=length_from)

    def i2h(self,pkt,x):
        return ":".join(["{:02x}".format(i) for i in x])

    def i2repr(self,pkt,x):
        return self.i2h(pkt, x)

    def any2i(self,pkt,x):
        if isinstance(x,str):
            x = bytes.fromhex(x.replace(":",""))
        return x

class ESB_Hdr(Packet):
    ESB_PREAMBLE_SIZE = 8
    ESB_PCF_SIZE = 9
    ESB_CRC_SIZE = 16
    ESB_PAYLEN_SIZE = 6

    name = "Enhanced ShockBurst packet"
    fields_desc = [
            XByteField("preamble",0xAA),
            FieldLenField("address_length", None, length_of="address"),
            SBAddressField("address",b"\0\0\0\0\0",length_from = lambda pkt:pkt.address_length),
            BitField("payload_length", None, 6),
            BitField("pid",None,2),
            BitField("no_ack", 0,1),
            BitField("padding",0,6),
            BitEnumField("valid_crc",0,1,{0:"no",1:"yes"}),
            XShortField("crc",None)
    ]

    def post_build(self,p,pay):
        preamble = bytes_to_bits(p[0:1])
        addrLen = unpack('>H',p[1:3])[0]

        address = bytes_to_bits(p[3:3+addrLen])
        header = bytes_to_bits(p[3+addrLen:3+addrLen+2])[:9]
        if self.payload_length is None:
            payLen = bytes_to_bits(pack('B',len(pay)))[2:]
            header = payLen + header[6:]
        payload = bytes_to_bits(pay)
        packet = bits_to_bytes(preamble + address + header + payload)
        if self.crc is None:
            crc = calculate_crc(packet[1:])
        else:
            crc = p[-2:]
        crc = bytes_to_bits(crc)
        return bits_to_bytes(preamble + address + header + payload + crc)


    def pre_dissect(self,s):
        if s[0] != 0xAA: # Dirty patch if no preamble is included
                s = b"\xAA"+s
        bitstring = bytes_to_bits(s)
        crc = None
        crcFound = False
        i = ESB_Hdr.ESB_PREAMBLE_SIZE+1
        # We try to guess the packet size by looking for a valid CRC
        while i < len(bitstring) - 16:
            if bytes_to_bits(calculate_crc(bits_to_bytes(bitstring[ESB_Hdr.ESB_PREAMBLE_SIZE:i]))) == bitstring[i:i+ESB_Hdr.ESB_CRC_SIZE]:
                crcFound = True
                break
            i += 1

        # We try to guess the address size by checking if :
        # ESB_PREAMBLE_SIZE + 8*addr_size + ESB_PCF_SIZE + payload_size = 8*packet_size - ESB_CRC_SIZE

        addrLenFound = False
        for addrLen in range(3,6):
            payLen = bits_to_bytes("00"+bitstring[ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8:ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8+ESB_Hdr.ESB_PAYLEN_SIZE])[0]
            if ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8+ESB_Hdr.ESB_PCF_SIZE+payLen*8 == i:
                addrLenFound = True
                break


        preamble = bitstring[:ESB_Hdr.ESB_PREAMBLE_SIZE]
        if crcFound and addrLenFound:
            # No problem, we know that the packet is valid
            address = bitstring[ESB_Hdr.ESB_PREAMBLE_SIZE:ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8]
            validCrc = "1" if crcFound else "0"
        else:
            # Our assumption is : addrLen = 5, invalid CRC
            addrLen = 5
            address = bitstring[ESB_Hdr.ESB_PREAMBLE_SIZE:ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8]
            validCrc = "0"

        pcf = bitstring[ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8:ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8+ESB_Hdr.ESB_PCF_SIZE]
        payloadLength = bits_to_bytes("00"+pcf[:6])[0]
        payload = bitstring[ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8+ESB_Hdr.ESB_PCF_SIZE:ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8+ESB_Hdr.ESB_PCF_SIZE+payloadLength*8]
        crc = bitstring[ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8+ESB_Hdr.ESB_PCF_SIZE+payloadLength*8:ESB_Hdr.ESB_PREAMBLE_SIZE+addrLen*8+ESB_Hdr.ESB_PCF_SIZE+payloadLength*8+ESB_Hdr.ESB_CRC_SIZE]

        padding = "0"*6

        return bits_to_bytes(preamble + bytes_to_bits(bytes([0,addrLen])) + address + pcf + padding + validCrc + crc + payload)


class ESB_Payload_Hdr(Packet):
    name = "ESB Payload"
    fields_desc = []

class ESB_Ping_Request(Packet):
        name = "ESB Ping Request"
        fields_desc = [StrFixedLenField('ping_payload', '\x0f\x0f\x0f\x0f', length=4)]

class ESB_Ack_Response(Packet):
        name = "ESB Ack Response"
        fields_desc = [StrField('ack_payload', '')]


class ESB_Pseudo_Packet(Packet):
    name = "ESB Pseudo packet"
    fields_desc = []

def guess_payload_class_esb(self, payload):
    if b"\x0f\x0f\x0f\x0f" == payload[:4]:
        return ESB_Ping_Request
    elif len(payload) == 0 or self.underlayer is not None and self.underlayer.no_ack == 1:
        return ESB_Ack_Response
    else:
        return Packet.guess_payload_class(self, payload)

ESB_Payload_Hdr.guess_payload_class = guess_payload_class_esb

bind_layers(ESB_Hdr,ESB_Payload_Hdr)
conf.l2types.register(USER_DLT, ESB_Hdr)
conf.l2types.register(USER_DLT, ESB_Pseudo_Packet)
